---
Title: 2024 Spring 課程w7
Date: 2024-04-26 14:00
Category: w7-40923116
Tags: 協同產品設計實習專案
Slug: 2024-Spring-w7-blog-tutorial-40923116
Author: 40923116
---

協同產品設計實習的專案實習, 透過 ChatGPT、Gemini 1.5 Pro 與 Claude 3 的協助下進行.

<!-- PELICAN_END_SUMMARY -->

# 協同資料處理

請各班各組根據 2a_cd2024_midterm.csv, 以及 2b_cd2024_midterm.csv 中的學號、Github 帳號與組別, 設法在各組員與分組網站中, 列出各學員的 cd2024 倉儲、網站, 以及各班各組的期中報告倉儲與網站連結.

過程中, 請詳細說明各組及學員的倉儲與網站中的連結資料如何建立? 手動輸入? 利用程式進行處理? 或者採分工合作方式建立?

2b step1 取出資料放入數列

# 鋼球平衡台 PID 控制與模擬

請下載 cd2024_ball_balancing_platform_control_ref.7z, 閱讀後請將摘要內容放入個人與分組網誌中.

對 Gemini 1.5 Pro 提問:

以下為利用 PID 控制 CoppeliaSim 鋼球平衡台場景的 ZMQ RemoteAPI Python 程式, 請利用 Python 模組將系統控制過程, 鋼球在平衡台上的 x 方向座標與 y 方向, 利用 matplotlib 畫出來. "這裡附上原本的 PID 控制程式碼"

回答:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
# 導入必要的模組
# pip install pyzmq cbor keyboard matplotlib
import matplotlib.pyplot as plt
from zmqRemoteApi_IPv6 import RemoteAPIClient
import keyboard

# 利用 zmqRemoteAPI 以 23000 對場景伺服器進行連線
client = RemoteAPIClient('localhost', 23000)

print('Program started')
sim = client.getObject('sim')

# Get the handles of the ball, motorx, and motory objects
ball_handle = sim.getObject('/ball')
motorx_handle = sim.getObject('/motorx')
motory_handle = sim.getObject('/motory')

# PID control constants for x and y coordinates
kp_x = 1.0  # Proportional gain for x
ki_x = 0.1  # Integral gain for x
kd_x = 0.5  # Derivative gain for x

kp_y = 1.0  # Proportional gain for y
ki_y = 0.1  # Integral gain for y
kd_y = 0.5  # Derivative gain for y

# Initialize error and integral terms for x and y coordinates
error_sum_x = 0.0
last_error_x = 0.0

error_sum_y = 0.0
last_error_y = 0.0

# 建立用於儲存 x 和 y 座標的列表
x_coordinates = []
y_coordinates = []

sim.startSimulation()
print('Simulation started')

# Function to get the ball's x and y coordinates
def getBallCoordinates():
    pos = sim.getObjectPosition(ball_handle, -1)
    x = pos[0]
    y = pos[1]
    return x, y

def controlMotor(target_x, target_y, dt):
    global error_sum_x, last_error_x, error_sum_y, last_error_y

    # Get the current ball coordinates
    current_x, current_y = getBallCoordinates()
    print("Target: (", target_x, ",", target_y, "), Current: (", current_x, ",", current_y, ")")

    # Calculate errors for x and y coordinates
    error_x = target_x - current_x
    error_y = target_y - current_y

    # Update error sums for x and y coordinates
    error_sum_x += error_x
    error_sum_y += error_y

    # Calculate derivatives for x and y coordinates
    derivative_x = (error_x - last_error_x) / dt
    derivative_y = (error_y - last_error_y) / dt

    # Calculate control signals for x and y coordinates
    control_signal_x = kp_x * error_x + ki_x * error_sum_x + kd_x * derivative_x
    control_signal_y = kp_y * error_y + ki_y * error_sum_y + kd_y * derivative_y

    # Set the rotational angles of motorx and motory
    sim.setJointTargetPosition(motorx_handle, control_signal_x)
    sim.setJointTargetPosition(motory_handle, control_signal_y)

    # Update the last errors for x and y coordinates
    last_error_x = error_x
    last_error_y = error_y

    # 儲存目前的 x 和 y 座標
    x_coordinates.append(current_x)
    y_coordinates.append(current_y)

while True:
    if keyboard.is_pressed('q'):
        # Stop simulation
        sim.stopSimulation()
        break

    # Control the motors to set the ball to the desired coordinates
    controlMotor(0.3, 0.3, 0.05)  # Adjust the time step (dt) and target coordinates as needed

# 在模擬結束後繪製圖形
plt.plot(x_coordinates, label='X Coordinate')
plt.plot(y_coordinates, label='Y Coordinate')
plt.xlabel('Time')
plt.ylabel('Coordinate')
plt.title('Ball Position on Balancing Platform')
plt.legend()
plt.show()
實習步驟:

開啟可攜程式系統中的 CoppeliaSim
開啟鋼球平衡台模擬場景
啟動可攜程式系統, pip install keyboard cbor pyzmq matplotlib
在 SciTE 中執行上列程式, 確定系統穩定後, 按下 q 終止模擬
matplotlib 將畫出鋼球在平台上的 x 與 y 座標圖


其他控制模擬參考資料: ball_beam_balancing_PID_control_coppeliasim_1d_and_2d_cd2024_w9.7z

若希望在不同電腦硬體上取得相同的 CoppeliaSim 場景控制模擬結果:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
# 導入必要的模組
# pip install pyzmq cbor keyboard matplotlib
import matplotlib.pyplot as plt
from zmqRemoteApi_IPv6 import RemoteAPIClient
import keyboard
import os
import random
import numpy as np

# Setting a fixed random seed for reproducibility
random.seed(42)  # Choose any fixed seed value

# 利用 zmqRemoteAPI 以 23000 對場景伺服器進行連線
client = RemoteAPIClient('localhost', 23000)

print('Program started')
sim = client.getObject('sim')

# Get the handles of the ball, motorx, and motory objects
ball_handle = sim.getObject('/ball')
motorx_handle = sim.getObject('/motorx')
motory_handle = sim.getObject('/motory')

# PID control constants for x and y coordinates
kp_x = 1.8839  # Proportional gain for x
ki_x = 0.1629  # Integral gain for x
kd_x = 0.5787  # Derivative gain for x

kp_y = 1.8839  # Proportional gain for x
ki_y = 0.1629  # Integral gain for x
kd_y = 0.5787  # Derivative gain for x

# Initialize error and integral terms for x and y coordinates
error_sum_x = 0.0
last_error_x = 0.0

error_sum_y = 0.0
last_error_y = 0.0

# 建立用於儲存 x 和 y 座標的列表
x_coordinates = []
y_coordinates = []

sim.startSimulation()
print('Simulation started')

# Function to get the ball's x and y coordinates
def getBallCoordinates():
    pos = sim.getObjectPosition(ball_handle, -1)
    x = pos[0]
    y = pos[1]
    return x, y

def controlMotor(target_x, target_y, dt):
    global error_sum_x, last_error_x, error_sum_y, last_error_y

    # Get the current simulation time
    simulation_time = sim.getSimulationTime() 

    # Adjust dt based on simulation time to account for potential slowdowns
    adjusted_dt = dt * sim.getSimulationTimeStep() / 0.05

    # Get the current ball coordinates
    current_x, current_y = getBallCoordinates()
    print("Target: (", target_x, ",", target_y, "), Current: (", current_x, ",", current_y, ")")

    # Calculate errors for x and y coordinates
    error_x = target_x - current_x
    error_y = target_y - current_y

    # Update error sums for x and y coordinates
    error_sum_x += error_x
    error_sum_y += error_y

    # Calculate derivatives for x and y coordinates
    derivative_x = (error_x - last_error_x) / adjusted_dt
    derivative_y = (error_y - last_error_y) / adjusted_dt

    # Calculate control signals for x and y coordinates
    control_signal_x = kp_x * error_x + ki_x * error_sum_x + kd_x * derivative_x
    control_signal_y = kp_y * error_y + ki_y * error_sum_y + kd_y * derivative_y

    # Set the rotational angles of motorx and motory
    sim.setJointTargetPosition(motorx_handle, control_signal_x)
    sim.setJointTargetPosition(motory_handle, control_signal_y)

    # Update the last errors for x and y coordinates
    last_error_x = error_x
    last_error_y = error_y

    # 儲存目前的 x 和 y 座標
    x_coordinates.append(current_x)
    y_coordinates.append(current_y)

while True:
    if keyboard.is_pressed('q'):
        # Stop simulation
        sim.stopSimulation()
        break

    # Control the motors to set the ball to the desired coordinates
    controlMotor(0.3, 0.3, 0.05)  # Adjust the time step (dt) and target coordinates as needed

# 在模擬結束後繪製圖形
plt.plot(x_coordinates, label='X Coordinate')
plt.plot(y_coordinates, label='Y Coordinate')
plt.xlabel('Time')
plt.ylabel('Coordinate')
plt.title('Ball Position on Balancing Platform')
plt.legend()
plt.show()
adjusted_dt = dt * sim.getSimulationTimeStep() / 0.05 設定主要用於動態調整控制迴路的更新頻率, 使其與 CoppeliaSim 模擬的實際速度保持同步. 如此可減輕因硬體性能差異導致的模擬速度變化所帶來的影響, 進而提高在不同電腦上得到相對較為一致的結果.

工作原理：

模擬時間步長 (Simulation Time Step): CoppeliaSim 使用固定時間步長進行物理模擬. 這個時間步長決定了模擬推進和更新場景中物件的位置、速度和其他狀態的時間間隔. 實際的模擬時間步長可能因場景複雜性和硬體性能等因素而略有不同.
控制迴路時序 (Control Loop Timing): Python 程式中的控制迴路以一定的頻率運行，由 dt 值（原始程式中為 0.05 秒）决定。 這意味著控制器每 0.05 秒計算新的控制信號並向馬達發送指令.
adjusted_dt 的計算: 如果模擬運行速度慢於實時(即模擬時間步長大於 0.05 秒), 控制迴路將比模擬更新運行得更快而導致問題, 因為控制器是基於過時的球的位置資料來做出決策的. 因此, adjusted_dt 會根據實際模擬時間步長與預期時間步長（0.05 秒）的比率，對原始 dt 值進行缩放： adjusted_dt = dt * sim.getSimulationTimeStep() / 0.05
對控制迴路的影響:

如果模擬運行速度比預期的慢(模擬時間步長 > 0.05 秒), adjusted_dt 將大於原始 dt. 這將有效地減慢了控制迴路的速度, 使其與模擬更新的速度相匹配.
通過使控制迴路與模擬速度同步, 控制器更有可能接收到關於球位置的最新資料，從而做出更好的控制決策並提高穩定性.
優點：

減少時序差異： adjusted_dt 有助於減輕控制迴路和模擬之間的時間不匹配, 這可能是不同硬體配置下控制性能差異的重要來源.
提高穩定性： 通過確保控制迴路以與模擬更新一致的速度運行, 控制器可以做出更明智的決策, 可能導致更好的穩定性和控制精度.
缺點：

非理想解決方案： 雖然 adjusted_dt 可以提高一致性, 但它并不能完全消除模擬速度變化帶來的問題. 其他因素, 例如網路延遲和數值精度, 仍然會導致結果的差異.
潛在的性能影響： 減慢控制迴路的速度可能會降低系統的響應能力, 尤其是在模擬運行速度明顯慢於實時的情況下.

--------

